#!/usr/bin/env python3
"""Generic PyInstaller build helper for any tool under the repository.

Dynamically reads tool configuration from pyproject.toml and builds with PyInstaller.
All configuration can be overridden via CLI arguments.
"""

from __future__ import annotations

import argparse
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any, Iterable

try:
    import tomllib
except ImportError:
    import tomli as tomllib  # type: ignore[import-not-found,no-redef]


def detect_os() -> str:
    system = platform.system()
    if system == "Windows":
        return "Windows"
    if system == "Darwin":
        return "Mac"
    if system == "Linux":
        return "Linux"
    raise SystemExit(f"Unsupported OS: {system}")


def run(cmd: list[str], cwd: Path | None = None, env: dict[str, str] | None = None) -> None:
    subprocess.run(cmd, check=True, cwd=cwd, env=env)


def install_venv(repo_root: Path, venv_name: str, noprompt: bool, force_python_version: str | None) -> None:
    installer = repo_root / "install_python_venv.ps1"
    if not installer.exists():
        raise SystemExit(f"install_python_venv.ps1 not found at {installer}")

    args = ["pwsh", "-File", str(installer)]
    if noprompt:
        args.append("-noprompt")
    args.extend(["-venv_name", venv_name])
    if force_python_version:
        args.extend(["-force_python_version", force_python_version])
    run(args)


UPX_EXCLUDES_WINDOWS_COMMON: list[str] = [
    "_uuid.pyd",
    "api-ms-win-crt-environment-l1-1-0.dll",
    "api-ms-win-crt-string-l1-1-0.dll",
    "api-ms-win-crt-convert-l1-1-0.dll",
    "api-ms-win-crt-heap-l1-1-0.dll",
    "api-ms-win-crt-conio-l1-1-0.dll",
    "api-ms-win-crt-filesystem-l1-1-0.dll",
    "api-ms-win-crt-stdio-l1-1-0.dll",
    "api-ms-win-crt-process-l1-1-0.dll",
    "api-ms-win-crt-locale-l1-1-0.dll",
    "api-ms-win-crt-time-l1-1-0.dll",
    "api-ms-win-crt-math-l1-1-0.dll",
    "api-ms-win-crt-runtime-l1-1-0.dll",
    "api-ms-win-crt-utility-l1-1-0.dll",
    "python3.dll",
    "api-ms-win-crt-private-l1-1-0.dll",
    "api-ms-win-core-timezone-l1-1-0.dll",
    "api-ms-win-core-file-l1-1-0.dll",
    "api-ms-win-core-processthreads-l1-1-1.dll",
    "api-ms-win-core-processenvironment-l1-1-0.dll",
    "api-ms-win-core-debug-l1-1-0.dll",
    "api-ms-win-core-localization-l1-2-0.dll",
    "api-ms-win-core-processthreads-l1-1-0.dll",
    "api-ms-win-core-errorhandling-l1-1-0.dll",
    "api-ms-win-core-handle-l1-1-0.dll",
    "api-ms-win-core-util-l1-1-0.dll",
    "api-ms-win-core-profile-l1-1-0.dll",
    "api-ms-win-core-rtlsupport-l1-1-0.dll",
    "api-ms-win-core-namedpipe-l1-1-0.dll",
    "api-ms-win-core-libraryloader-l1-1-0.dll",
    "api-ms-win-core-file-l1-2-0.dll",
    "api-ms-win-core-synch-l1-2-0.dll",
    "api-ms-win-core-sysinfo-l1-1-0.dll",
    "api-ms-win-core-console-l1-1-0.dll",
    "api-ms-win-core-string-l1-1-0.dll",
    "api-ms-win-core-memory-l1-1-0.dll",
    "api-ms-win-core-synch-l1-1-0.dll",
    "api-ms-win-core-interlocked-l1-1-0.dll",
    "api-ms-win-core-datetime-l1-1-0.dll",
    "api-ms-win-core-file-l2-1-0.dll",
    "api-ms-win-core-heap-l1-1-0.dll",
]


def apply_tool_preset(
    args: argparse.Namespace,
    repo_root: Path,
    tool_path: Path,
    src_dir: Path,
    os_name: str,
) -> None:
    preset = (args.preset or "").lower()
    if not preset:
        return

    data_sep = path_separator_for_data(os_name)
    if os_name == "Mac":
        icon_ext = "icns"
    else:
        icon_ext = "ico"

    if preset in {"toolset", "holocrontoolset"}:
        args.entrypoint = args.entrypoint or "toolset/__main__.py"
        args.name = args.name or "HolocronToolset"
        if not args.console:
            args.windowed = True
        args.include_wiki_if_present = True

        icon_candidate = src_dir / "resources" / "icons" / f"sith.{icon_ext}"
        if not args.icon and icon_candidate.exists():
            args.icon = str(icon_candidate)

        args.hidden_import.extend(
            [
                "utility",
                "utility.error_handling",
                "utility.common",
                "utility.system",
                "utility.gui",
                "utility.updater",
            ]
        )
        args.exclude_module.extend(["dl_translate", "torch"])
        if args.qt_api:
            args.exclude_other_qt = True

        vendor_src = repo_root / "vendor" / "kotorblender" / "io_scene_kotor"
        if vendor_src.exists():
            args.add_data_if_exists.append(f"{vendor_src}{data_sep}kotorblender/io_scene_kotor")

        if os_name == "Windows":
            args.upx_exclude.extend(UPX_EXCLUDES_WINDOWS_COMMON)

    elif preset in {"holopatcher"}:
        args.entrypoint = args.entrypoint or "holopatcher/__main__.py"
        args.name = args.name or "HoloPatcher"
        if not args.windowed:
            args.console = True
        args.debug = args.debug or "imports"
        args.log_level = args.log_level or "INFO"

        icon_candidate = src_dir / "holopatcher" / "resources" / "icons" / f"patcher_icon_v2.{icon_ext}"
        if not args.icon and icon_candidate.exists():
            args.icon = str(icon_candidate)

        args.exclude_module.extend(
            [
                "PyQt5",
                "PyQt5-Qt5",
                "PyQt5-sip",
                "PyQt6",
                "PyQt6-Qt6",
                "PyQt6-sip",
                "PySide2",
                "PySide6",
                "PyOpenGL",
                "PyGLM",
                "dl_translate",
                "torch",
                "deep_translator",
                "cefpython3",
            ]
        )
        if os_name == "Windows":
            args.upx_exclude.extend(UPX_EXCLUDES_WINDOWS_COMMON)

    elif preset in {"batchpatcher", "translator"}:
        args.entrypoint = args.entrypoint or "batchpatcher/__main__.py"
        args.name = args.name or "K_BatchPatcher"
        if not args.console:
            args.windowed = True
        args.preinstall_playwright = True

        args.exclude_module.extend(
            [
                "dl_translate",
                "torch",
                "PyQt5",
                "PyQt5-Qt5",
                "PyQt5-sip",
                "PyQt6",
                "PyQt6-Qt6",
                "PyQt6-sip",
                "PySide2",
                "PySide6",
                "PyOpenGL",
                "PyGLM",
                "numpy",
                "pykotor-gl",
            ]
        )
        if os_name == "Windows":
            args.upx_exclude.extend(UPX_EXCLUDES_WINDOWS_COMMON)

    elif preset in {"kotordiff"}:
        args.entrypoint = args.entrypoint or "kotordiff/__main__.py"
        args.name = args.name or "KotorDiff"
        if not args.windowed:
            args.console = True

        args.exclude_module.extend(
            [
                "arabic-reshaper",
                "beautifulsoup4",
                "cssselect",
                "deep_translator",
                "deepl-cli",
                "dl_translate",
                "greenlet",
                "install_playwright",
                "isort",
                "Markdown",
                "matplotlib",
                "mypy-extensions",
                "mypy",
                "numpy",
                "PIL",
                "Pillow",
                "playwright",
                "PyGLM",
                "pykotor.font",
                "pykotor.gl",
                "pykotor.secure_xml",
                "pykotorgl",
                "pylint",
                "PyOpenGL",
                "PyQt5-Qt5",
                "PyQt5-sip",
                "PyQt5",
                "PyQt6-Qt6",
                "PyQt6-sip",
                "PyQt6",
                "pyquery",
                "PySide2",
                "PySide6",
                "ruff",
                "setuptools",
                "torch",
                "watchdog",
                "wheel",
            ]
        )
        if os_name == "Windows":
            args.upx_exclude.extend(UPX_EXCLUDES_WINDOWS_COMMON)


def path_separator_for_data(os_name: str) -> str:
    return ";" if os_name == "Windows" else ":"


def add_flag_values(flag: str, values: Iterable[str], buffer: list[str]) -> None:
    for value in values:
        buffer.append(f"--{flag}={value}")


def compute_final_executable(distpath: Path, name: str, os_name: str, windowed: bool = False) -> Path:
    """Compute the expected executable path based on OS and windowed mode.
    
    On macOS:
    - windowed=True: Creates .app bundle
    - windowed=False: Creates regular executable (no extension)
    On Windows:
    - Always creates .exe
    On Linux:
    - Always creates regular executable (no extension)
    """
    if os_name == "Windows":
        return distpath / f"{name}.exe"
    elif os_name == "Mac":
        if windowed:
            return distpath / f"{name}.app"
        else:
            return distpath / name
    else:  # Linux
        return distpath / name


def normalize_add_data(entries: Iterable[str], sep: str) -> list[str]:
    normalized: list[str] = []
    for entry in entries:
        if ":" not in entry and sep == ":":
            raise SystemExit(f"--add-data entry '{entry}' missing destination (use src{sep}dest)")
        if ";" not in entry and sep == ";" and ":" not in entry:
            raise SystemExit(f"--add-data entry '{entry}' missing destination (use src{sep}dest)")
        normalized.append(entry)
    return normalized


def main() -> None:
    repo_root = Path(__file__).resolve().parent.parent
    parser = argparse.ArgumentParser(description="Generic PyInstaller compiler for repository tools")
    parser.add_argument("--tool-path", required=True, help="Path to the tool directory (e.g., Tools/HoloPatcher)")
    parser.add_argument("--preset", help="Apply a known tool preset (toolset/holopatcher/batchpatcher/kotordiff)")
    parser.add_argument("--src-dir", help="Override src directory (defaults to <tool-path>/src)")
    parser.add_argument("--entrypoint", help="Relative path from src to __main__ (defaults to <slug>/__main__.py)")
    parser.add_argument("--name", help="PyInstaller --name (defaults to tool directory name)")
    parser.add_argument("--distpath", help="Output directory (defaults to <repo>/dist)")
    parser.add_argument("--workpath", help="PyInstaller workpath (defaults to <src>/build)")
    parser.add_argument("--icon", help="Icon path passed to PyInstaller")
    parser.add_argument("--hidden-import", action="append", default=[], help="Repeatable hidden imports")
    parser.add_argument("--exclude-module", action="append", default=[], help="Repeatable exclusions")
    parser.add_argument("--upx-exclude", action="append", default=[], help="Repeatable UPX exclusions")
    parser.add_argument("--add-data", action="append", default=[], help="Repeatable --add-data entries (src{sep}dest)")
    parser.add_argument("--add-data-if-exists", action="append", default=[], help="Optional --add-data entries only if src exists")
    parser.add_argument("--extra-path", action="append", default=[], help="Additional --path entries for PyInstaller")
    parser.add_argument("--inherit-pythonpath", action="store_true", default=True, help="Include PYTHONPATH entries")
    parser.add_argument("--no-inherit-pythonpath", dest="inherit_pythonpath", action="store_false")
    parser.add_argument("--include-library-src", action="store_true", default=True, help="Include all Libraries/*/src paths when present")
    parser.add_argument("--no-include-library-src", dest="include_library_src", action="store_false")
    parser.add_argument("--include-wiki-if-present", action="store_true", help="Bundle wiki directory if it exists")
    parser.add_argument("--wiki-dest", default="wiki", help="Destination folder name for wiki add-data")
    parser.add_argument("--clean", action="store_true", default=True, help="Enable PyInstaller --clean and remove workpath")
    parser.add_argument("--no-clean", dest="clean", action="store_false")
    parser.add_argument("--onefile", action="store_true", default=True)
    parser.add_argument("--no-onefile", dest="onefile", action="store_false")
    parser.add_argument("--noconfirm", action="store_true", default=True)
    parser.add_argument("--no-noconfirm", dest="noconfirm", action="store_false")
    parser.add_argument("--windowed", action="store_true", help="Use windowed mode")
    parser.add_argument("--console", action="store_true", help="Force console mode")
    parser.add_argument("--debug", help="Debug setting for PyInstaller")
    parser.add_argument("--log-level", help="Log level for PyInstaller")
    parser.add_argument("--upx-dir", help="Path to UPX binary")
    parser.add_argument("--qt-api", help="Normalize QT_API environment variable and exclude other bindings")
    parser.add_argument("--exclude-other-qt", action="store_true", default=False, help="Exclude other Qt bindings when qt-api is set")
    parser.add_argument("--preinstall-playwright", action="store_true", help="Run 'playwright install' before building")
    parser.add_argument("--playwright-browser", action="append", default=["chromium"], help="Browsers to install with playwright")
    parser.add_argument("--pre-pip", action="append", default=[], help="Packages to pip install before running PyInstaller")
    parser.add_argument("--venv-name", default=".venv", help="Virtual environment name")
    parser.add_argument("--skip-venv", action="store_true", help="Skip install_python_venv.ps1 invocation")
    parser.add_argument("--noprompt", action="store_true", help="Skip prompts in install_python_venv.ps1")
    parser.add_argument("--force-python-version", help="Force Python version when creating the venv (passed to install_python_venv.ps1)")
    parser.add_argument("--python-exe", default=os.environ.get("pythonExePath", "python"), help="Python executable to use")
    parser.add_argument("--remove-previous", action="store_true", default=True, help="Remove prior dist artifacts for this tool")
    parser.add_argument("--no-remove-previous", dest="remove_previous", action="store_false")
    args = parser.parse_args()
    
    # Validate python_exe exists if skip_venv is True (when venv is pre-created)
    if args.skip_venv and args.python_exe:
        python_exe_path = Path(args.python_exe)
        if not python_exe_path.exists():
            raise SystemExit(
                f"Python executable not found at {args.python_exe}. "
                f"This is required when --skip-venv is used. "
                f"Ensure the venv was created and pythonExePath is set correctly."
            )

    os_name = detect_os()
    tool_path = (repo_root / args.tool_path).resolve() if not Path(args.tool_path).is_absolute() else Path(args.tool_path)
    src_dir = Path(args.src_dir) if args.src_dir else tool_path / "src"
    if not src_dir.exists():
        raise SystemExit(f"src directory not found: {src_dir}")

    apply_tool_preset(args, repo_root, tool_path, src_dir, os_name)

    name = args.name or Path(tool_path).name
    distpath = Path(args.distpath) if args.distpath else repo_root / "dist"
    workpath = Path(args.workpath) if args.workpath else src_dir / "build"

    entrypoint = args.entrypoint
    if not entrypoint:
        slug = Path(tool_path).name.lower()
        entrypoint = f"{slug}/__main__.py"

    data_sep = path_separator_for_data(os_name)

    # Prepare environment
    env = os.environ.copy()
    if args.qt_api:
        env["QT_API"] = args.qt_api
    if args.exclude_other_qt and args.qt_api:
        normalized_api = args.qt_api
        all_bindings = {"PyQt5", "PyQt6", "PySide2", "PySide6"}
        other_bindings = sorted(api for api in all_bindings if api != normalized_api)
        args.exclude_module.extend(other_bindings)

    if not args.skip_venv:
        # install_python_venv.ps1 handles venv creation, activation, and Python installation
        # We trust it to set up the environment correctly
        install_venv(repo_root, args.venv_name, args.noprompt, args.force_python_version)
        # Use venv Python executable directly - install_python_venv.ps1 ensures it exists and has pip
        venv_python = repo_root / args.venv_name / ("Scripts" if os_name == "Windows" else "bin") / ("python.exe" if os_name == "Windows" else "python")
        if venv_python.exists():
            args.python_exe = str(venv_python)
        else:
            # Fallback: try common venv names if the requested one doesn't exist
            # This handles cases where install_python_venv.ps1 creates a versioned venv
            venv_found = False
            for alt_venv_name in [".venv_3.13", ".venv_3.12", ".venv_3.11", ".venv_3.10", ".venv_3.9"]:
                alt_venv_python = repo_root / alt_venv_name / ("Scripts" if os_name == "Windows" else "bin") / ("python.exe" if os_name == "Windows" else "python")
                if alt_venv_python.exists():
                    args.python_exe = str(alt_venv_python)
                    venv_found = True
                    break
            if not venv_found:
                raise SystemExit(
                    f"Virtual environment creation failed: expected venv at {venv_python.parent.parent} but it does not exist. "
                    f"Checked fallback venvs: .venv_3.13, .venv_3.12, .venv_3.11, .venv_3.10, .venv_3.9"
                )

    if args.pre_pip:
        run([args.python_exe, "-m", "pip", "install", *args.pre_pip, "--prefer-binary", "--progress-bar", "on"], env=env)

    # Only install playwright when explicitly requested via --preinstall-playwright
    if args.preinstall_playwright:
        # Check if playwright is already installed to avoid unnecessary installation
        result = subprocess.run(
            [args.python_exe, "-c", "import playwright"],
            env=env,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            print("Installing playwright...")
            run([args.python_exe, "-m", "pip", "install", "playwright", "--prefer-binary", "--progress-bar", "on"], env=env)
        # Install playwright browsers
        env["PLAYWRIGHT_BROWSERS_PATH"] = env.get("PLAYWRIGHT_BROWSERS_PATH", "0")
        for browser in args.playwright_browser:
            run([args.python_exe, "-m", "playwright", "install", browser], env=env)

    # Collect PyInstaller args
    pyinstaller_args: list[str] = []
    if args.clean:
        pyinstaller_args.append("--clean")
    if args.onefile:
        pyinstaller_args.append("--onefile")
    if args.noconfirm:
        pyinstaller_args.append("--noconfirm")
    if args.windowed and not args.console:
        pyinstaller_args.append("--windowed")
    if args.console and not args.windowed:
        pyinstaller_args.append("--console")
    if args.debug:
        pyinstaller_args.append(f"--debug={args.debug}")
    if args.log_level:
        pyinstaller_args.append(f"--log-level={args.log_level}")
    if args.icon:
        pyinstaller_args.append(f"--icon={args.icon}")
    pyinstaller_args.append(f"--name={name}")
    pyinstaller_args.append(f"--distpath={distpath}")
    pyinstaller_args.append(f"--workpath={workpath}")
    if args.upx_dir:
        pyinstaller_args.append(f"--upx-dir={args.upx_dir}")

    add_flag_values("hidden-import", args.hidden_import, pyinstaller_args)
    add_flag_values("exclude-module", args.exclude_module, pyinstaller_args)
    add_flag_values("upx-exclude", args.upx_exclude, pyinstaller_args)

    add_data_entries: list[str] = list(args.add_data)
    for candidate in args.add_data_if_exists:
        src, _, dest = candidate.partition(data_sep)
        if not src:
            continue
        if Path(src).expanduser().exists():
            add_data_entries.append(candidate)

    if args.include_wiki_if_present:
        wiki_dir = repo_root / "wiki"
        if wiki_dir.exists():
            add_data_entries.append(f"{wiki_dir}{data_sep}{args.wiki_dest}")

    normalized_data = normalize_add_data(add_data_entries, data_sep)
    add_flag_values("add-data", normalized_data, pyinstaller_args)

    paths: List[str] = []
    if args.include_library_src:
        libraries_dir = repo_root / "Libraries"
        if libraries_dir.exists():
            for child in libraries_dir.iterdir():
                candidate = child / "src"
                if candidate.exists():
                    paths.append(str(candidate))
    paths.extend(args.extra_path)
    if args.inherit_pythonpath:
        paths.extend([p for p in env.get("PYTHONPATH", "").split(os.pathsep) if p])

    add_flag_values("path", paths, pyinstaller_args)

    entry_arg = str(Path(entrypoint))
    pyinstaller_args.append(entry_arg)

    # Determine if windowed mode is used (for macOS .app bundle detection)
    is_windowed = args.windowed and not args.console
    final_executable = compute_final_executable(distpath, name, os_name, windowed=is_windowed)
    if args.remove_previous:
        if final_executable.exists():
            if final_executable.is_dir():
                shutil.rmtree(final_executable)
            else:
                final_executable.unlink()
        alt_dir = distpath / name
        if alt_dir.exists():
            shutil.rmtree(alt_dir)

        if args.clean and workpath.exists():
            shutil.rmtree(workpath)

    cmd = [args.python_exe, "-m", "PyInstaller"] + pyinstaller_args
    print("Executing:", " ".join(cmd))
    run(cmd, cwd=src_dir, env=env)

    if not final_executable.exists():
        raise SystemExit(f"Build failed, expected output missing: {final_executable}")
    print(f"Built executable at: {final_executable}")


if __name__ == "__main__":
    main()

