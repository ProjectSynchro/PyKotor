name: 'Build PyKotor Tool'
description: 'Reusable action to build a PyKotor tool with PyInstaller'

inputs:
  tool_path:
    description: 'Path to the tool directory (e.g., Tools/HolocronToolset)'
    required: true
  tool_display_name:
    description: 'Display name for artifacts (defaults to tool directory name)'
    required: false
    default: ''
  tool_requires_qt:
    description: 'Whether the tool requires Qt (true/false)'
    required: false
    default: 'false'
  python_version:
    description: 'Python version to use'
    required: false
    default: '3.8'
  architecture:
    description: 'Architecture (x86 or x64)'
    required: false
    default: 'x64'
  qt_api:
    description: 'Qt API for GUI tools (PyQt5, PyQt6, PySide6, etc.)'
    required: false
    default: 'PyQt6'
  upx_version:
    description: 'UPX version for compression'
    required: false
    default: '4.2.2'
  upload_artifact:
    description: 'Whether to upload the built artifact'
    required: false
    default: 'true'
  artifact_retention_days:
    description: 'Number of days to retain the artifact'
    required: false
    default: '7'
  dry_run:
    description: 'If true, only validates build without full compilation'
    required: false
    default: 'false'

outputs:
  build_success:
    description: 'Whether the build succeeded'
    value: ${{ steps.build.outputs.success }}
  artifact_name:
    description: 'Name of the uploaded artifact'
    value: ${{ steps.artifact_name.outputs.name }}

runs:
  using: 'composite'
  steps:
    - name: Determine artifact name
      id: artifact_name
      shell: pwsh
      run: |
        $toolPath = "${{ inputs.tool_path }}"
        $toolDir = [System.IO.Path]::GetFileName($toolPath.TrimEnd('/', '\\'))
        $displayName = if ("${{ inputs.tool_display_name }}") { "${{ inputs.tool_display_name }}" } else { $toolDir }
        $artifactName = "${displayName}_${{ runner.os }}_${{ inputs.architecture }}"
        if ("${{ inputs.tool_requires_qt }}" -eq "true") {
          $artifactName = "${displayName}_${{ runner.os }}_${{ inputs.qt_api }}_${{ inputs.architecture }}"
        }
        echo "name=$artifactName" >> $env:GITHUB_OUTPUT
        echo "display_name=$displayName" >> $env:GITHUB_OUTPUT

    - name: Install PowerShell (non-Windows)
      if: runner.os != 'Windows'
      shell: bash
      run: |
        if [ -f "./install_powershell.sh" ]; then
          bash ./install_powershell.sh
        fi

    - name: Reset APT sources (Linux)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        echo "Resetting APT sources to default Ubuntu repositories"
        sudo rm -f /etc/apt/sources.list
        echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs) main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
        echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs)-updates main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
        echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs)-backports main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
        echo "deb http://security.ubuntu.com/ubuntu $(lsb_release -cs)-security main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
        sudo apt-get update -y

    - name: Download and prepare UPX
      if: runner.os != 'macOS' && inputs.dry_run != 'true'
      shell: pwsh
      run: |
        $upxVersion = "${{ inputs.upx_version }}"
        $archiveName = ""
        if ("${{ runner.os }}" -eq "Windows") {
          $archiveName = if ("${{ inputs.architecture }}" -eq "x86") { "upx-$upxVersion-win32.zip" } else { "upx-$upxVersion-win64.zip" }
        } elseif ("${{ runner.os }}" -eq "Linux") {
          $archiveName = "upx-$upxVersion-amd64_linux.tar.xz"
        }
        if ($archiveName) {
          $url = "https://github.com/upx/upx/releases/download/v$upxVersion/$archiveName"
          if ("${{ runner.os }}" -eq "Windows") {
            Invoke-WebRequest -Uri $url -OutFile $archiveName
          } else {
            curl -L $url -o $archiveName
          }
          New-Item -ItemType Directory -Force -Path "upx-dir" -ErrorAction SilentlyContinue
          if ($archiveName -like "*.zip") {
            $fileNameWithoutExtension = [System.IO.Path]::GetFileNameWithoutExtension($archiveName)
            Expand-Archive -Path $archiveName -DestinationPath "temp_folder_upx"
            Get-ChildItem -LiteralPath "temp_folder_upx/$fileNameWithoutExtension" -Recurse | Move-Item -Destination "upx-dir"
            Remove-Item "temp_folder_upx" -Recurse -Force -ErrorAction SilentlyContinue
          } else {
            tar -xvf $archiveName --strip-components=1 -C "upx-dir"
          }
          Remove-Item $archiveName -ErrorAction SilentlyContinue
        }

    - name: Set UPX directory path
      if: runner.os != 'macOS' && inputs.dry_run != 'true'
      shell: pwsh
      run: |
        $upx_dir = $([System.IO.Path]::GetFullPath('./upx-dir'))
        echo "UPX_DIR=$upx_dir" | Out-File -FilePath $env:GITHUB_ENV -Append

    - name: Install Visual Studio C++ Redistributable (Windows)
      if: runner.os == 'Windows' && inputs.dry_run != 'true'
      shell: pwsh
      run: |
        $redistUrl = if ("${{ inputs.architecture }}" -eq "x86") {
          "https://aka.ms/vs/17/release/vc_redist.x86.exe"
        } else {
          "https://aka.ms/vs/17/release/vc_redist.x64.exe"
        }
        Invoke-WebRequest -Uri $redistUrl -OutFile "vc_redist.exe"
        Start-Process "vc_redist.exe" -ArgumentList '/install', '/quiet', '/norestart' -Wait
        Remove-Item -Path "vc_redist.exe"

    - name: Setup Python environment and install dependencies
      id: deps
      shell: pwsh
      run: |
        try {
          $toolPath = "${{ inputs.tool_path }}"
          $toolDir = [System.IO.Path]::GetFileName($toolPath.TrimEnd('/', '\\'))
          $venvName = ".venv_${toolDir}_${{ runner.os }}_${{ inputs.python_version }}_${{ inputs.architecture }}"

          $depsArgs = @(
            "--tool-path", $toolPath,
            "--venv-name", $venvName,
            "--noprompt",
            "--force-python-version", "${{ inputs.python_version }}",
            "--pip-requirements", "./Libraries/PyKotor/requirements.txt"
          )

          if ("${{ inputs.tool_requires_qt }}" -eq "true") {
            $depsArgs += @(
              "--qt-api", "${{ inputs.qt_api }}"
            )
          }

          Write-Host "Installing dependencies via compile/deps_tool.ps1: $($depsArgs -join ' ')"
          & ./compile/deps_tool.ps1 @depsArgs
          if ($LASTEXITCODE -ne 0) { throw "deps_tool.ps1 failed with exit code $LASTEXITCODE" }

          # Compute venv Python path (used in later steps)
          $repoRoot = (Get-Location).Path
          $venvPython = if ("${{ runner.os }}" -eq "Windows") {
            Join-Path $repoRoot "$venvName/Scripts/python.exe"
          } else {
            Join-Path $repoRoot "$venvName/bin/python"
          }
          if (-not (Test-Path -LiteralPath $venvPython)) {
            throw "Venv python not found at $venvPython"
          }

          echo "success=true" >> $env:GITHUB_OUTPUT
          echo "venv_name=$venvName" >> $env:GITHUB_OUTPUT
          echo "venv_python=$venvPython" >> $env:GITHUB_OUTPUT
          echo "tool_path=$toolPath" >> $env:GITHUB_OUTPUT
        } catch {
          Write-Host -ForegroundColor Red "Error: $($_.Exception.Message)"
          echo "success=false" >> $env:GITHUB_OUTPUT
          exit 1
        }

    - name: Validate build configuration (dry run)
      if: inputs.dry_run == 'true'
      shell: pwsh
      run: |
        $venvName = "${{ steps.deps.outputs.venv_name }}"
        $venvPython = "${{ steps.deps.outputs.venv_python }}"

        Write-Host "=== DRY RUN: Validating build configuration ==="

        # Check core build wrappers exist
        if (-not (Test-Path -LiteralPath "./compile/compile_tool.ps1")) {
          Write-Error "compile/compile_tool.ps1 not found"
          exit 1
        }
        if (-not (Test-Path -LiteralPath "./compile/deps_tool.ps1")) {
          Write-Error "compile/deps_tool.ps1 not found"
          exit 1
        }
        Write-Host "✓ Core build wrappers exist"

        if (-not (Test-Path -LiteralPath $venvPython)) {
          Write-Error "Venv python missing: $venvPython"
          exit 1
        }
        Write-Host "✓ Venv python exists: $venvPython"

        # Check PyInstaller
        $pyinstallerVersion = & $venvPython -m pip show pyinstaller 2>$null | Select-String "Version"
        if ($pyinstallerVersion) {
          Write-Host "✓ PyInstaller installed: $pyinstallerVersion"
        } else {
          Write-Error "PyInstaller not found"
          exit 1
        }

        Write-Host ""
        Write-Host "=== DRY RUN COMPLETE: Build configuration validated ==="

    - name: Build tool
      id: build
      if: inputs.dry_run != 'true'
      shell: pwsh
      run: |
        try {
          $venvName = "${{ steps.deps.outputs.venv_name }}"
          $venvPython = "${{ steps.deps.outputs.venv_python }}"
          $toolPath = "${{ steps.deps.outputs.tool_path }}"
          $upxDir = $env:UPX_DIR

          if (-not (Test-Path -LiteralPath $venvPython)) {
            Write-Error "Venv python missing: $venvPython"
            echo "success=false" >> $env:GITHUB_OUTPUT
            exit 1
          }

          $env:PYTHONOPTIMIZE = "1"
          $compileArgs = @(
            "--tool-path", $toolPath,
            "--venv-name", $venvName,
            "--skip-venv",
            "--python-exe", $venvPython,
            "--noprompt"
          )
          if ($upxDir) { $compileArgs += @("--upx-dir", $upxDir) }
          if ("${{ inputs.tool_requires_qt }}" -eq "true") {
            $compileArgs += @("--qt-api", "${{ inputs.qt_api }}", "--exclude-other-qt")
          }

          $output = ""
          $errorLines = @()
          & ./compile/compile_tool.ps1 @compileArgs 2>&1 | ForEach-Object {
            Write-Output $_.ToString()
            $output += $_.ToString() + "`n"
            if ($_ -match 'ERROR:') {
              $errorLines += $_.ToString()
            }
          }

          $warningCount = 0
          $output -split "`n" | ForEach-Object {
            if ($_ -match 'WARNING: Library not found: could not resolve' -or
                $_ -match 'WARNING: Cannot find ' -or
                $_ -match 'WARNING: lib not found:' -or
                $_ -match 'WARNING: Tcl modules directory' -or
                $_ -match 'WARNING: Failed to upx strip') {
              $warningCount++
            }
          }

          if ($errorLines.Count -gt 0) {
            $errorLines | ForEach-Object { Write-Error $_ }
            echo "success=false" >> $env:GITHUB_OUTPUT
            exit 1
          } elseif ($warningCount -ge 3) {
            Write-Output "Many warnings raised, pyinstaller may have issues."
            echo "success=false" >> $env:GITHUB_OUTPUT
            exit 1
          } else {
            echo "success=true" >> $env:GITHUB_OUTPUT
          }
        } catch {
          Write-Host -ForegroundColor Red "Build error: $($_.Exception.Message)"
          echo "success=false" >> $env:GITHUB_OUTPUT
          exit 1
        }

    - name: Upload build artifact
      if: inputs.upload_artifact == 'true' && inputs.dry_run != 'true' && steps.build.outputs.success == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.artifact_name.outputs.name }}
        path: ./dist/**
        retention-days: ${{ inputs.artifact_retention_days }}
